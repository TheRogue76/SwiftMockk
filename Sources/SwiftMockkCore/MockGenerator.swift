import Foundation

/// Generates mock class source code from protocol information
public struct MockGenerator {

    public init() {}

    /// Generate a complete mock class implementation for the given protocol
    /// - Parameters:
    ///   - protocolInfo: The protocol information to generate a mock for
    ///   - includeImports: Whether to include import statements
    /// - Returns: Swift source code for the mock class
    public func generateMock(for protocolInfo: ProtocolInfo, includeImports: Bool = false) -> String {
        var output = ""

        // Add imports if requested
        if includeImports {
            output += "import Foundation\n"
            output += "import SwiftMockk\n"
            if let moduleName = protocolInfo.moduleName {
                output += "@testable import \(moduleName)\n"
            }
            output += "\n"
        }

        // Generate the mock class
        output += generateMockClass(for: protocolInfo)

        return output
    }

    /// Generate multiple mock classes for a list of protocols
    /// - Parameters:
    ///   - protocols: List of protocol information
    ///   - moduleName: The module to import
    /// - Returns: Swift source code containing all mock classes
    public func generateMocks(for protocols: [ProtocolInfo], moduleName: String?) -> String {
        var output = """
        // Generated by SwiftMockkGenerator - DO NOT EDIT
        // Generation time: \(ISO8601DateFormatter().string(from: Date()))

        import Foundation
        import SwiftMockk

        """

        if let moduleName = moduleName {
            output += "@testable import \(moduleName)\n"
        }

        output += "\n"

        // Track non-generic protocols for auto-registration
        var nonGenericProtocols: [ProtocolInfo] = []

        for protocolInfo in protocols {
            output += generateMockClass(for: protocolInfo)
            output += "\n"

            // Track non-generic protocols
            if !isGenericProtocol(protocolInfo) {
                nonGenericProtocols.append(protocolInfo)
            }
        }

        // Generate auto-registration code
        if !nonGenericProtocols.isEmpty {
            output += generateAutoRegistration(for: nonGenericProtocols)
        }

        return output
    }

    /// Check if a protocol is generic (has type parameters or associated types)
    private func isGenericProtocol(_ protocolInfo: ProtocolInfo) -> Bool {
        return protocolInfo.genericParameters != nil || !protocolInfo.associatedTypes.isEmpty
    }

    /// Generate auto-registration code at the end of the file
    private func generateAutoRegistration(for protocols: [ProtocolInfo]) -> String {
        var output = "// MARK: - Auto-Registration\n\n"

        // Generate _registerAllMocks function
        output += "private func _registerAllMocks() {\n"
        for protocolInfo in protocols {
            let mockClassName = "Mock\(protocolInfo.name)"
            output += "    \(mockClassName).ensureRegistered()\n"
        }
        output += "}\n\n"

        // Generate _autoRegister to trigger registration
        output += "private let _autoRegister: Void = {\n"
        output += "    _registerAllMocks()\n"
        output += "}()\n"

        return output
    }

    // MARK: - Private Implementation

    private func generateMockClass(for protocolInfo: ProtocolInfo) -> String {
        let mockClassName = "Mock\(protocolInfo.name)"
        let protocolName = protocolInfo.name
        let isGeneric = isGenericProtocol(protocolInfo)

        // Determine final generics
        let finalGenerics = computeFinalGenerics(for: protocolInfo)
        let finalWhereClause = computeFinalWhereClause(for: protocolInfo)

        // Build class declaration
        var classDecl = "public class \(mockClassName)"
        if let generics = finalGenerics {
            classDecl += generics
        }
        classDecl += ": \(protocolName), Mockable"
        if let whereClause = finalWhereClause {
            classDecl += " \(whereClause)"
        }
        classDecl += " {\n"

        // Add infrastructure
        classDecl += "    public let _mockId = UUID().uuidString\n"
        classDecl += "    public var _recorder: CallRecorder { CallRecorder.shared(for: _mockId) }\n"
        classDecl += "    public var _mockMode: MockMode = .strict\n"
        classDecl += "\n"

        // Add registration code for non-generic mocks
        if !isGeneric {
            classDecl += "    // Auto-registration for mockk() support\n"
            classDecl += "    private static let _registerOnce: Void = {\n"
            classDecl += "        MockRegistry.shared.register(\(protocolName).self) { mode in\n"
            classDecl += "            \(mockClassName)(mode: mode)\n"
            classDecl += "        }\n"
            classDecl += "    }()\n"
            classDecl += "\n"
            classDecl += "    @discardableResult\n"
            classDecl += "    public static func ensureRegistered() -> Bool {\n"
            classDecl += "        _ = _registerOnce\n"
            classDecl += "        return true\n"
            classDecl += "    }\n"
            classDecl += "\n"
            classDecl += "    public init(mode: MockMode = .strict) {\n"
            classDecl += "        _ = _autoRegister  // Ensure all mocks are registered\n"
            classDecl += "        _mockMode = mode\n"
            classDecl += "    }\n"
        } else {
            classDecl += "    public init(mode: MockMode = .strict) { _mockMode = mode }\n"
        }
        classDecl += "\n"

        // Add typealias for associated types
        for assocType in protocolInfo.associatedTypes {
            classDecl += "    public typealias \(assocType.name) = \(assocType.name)\n"
        }
        if !protocolInfo.associatedTypes.isEmpty {
            classDecl += "\n"
        }

        // Generate properties
        for property in protocolInfo.properties {
            classDecl += generateMockProperty(for: property)
            classDecl += "\n"
        }

        // Generate methods
        for method in protocolInfo.methods {
            classDecl += generateMockMethod(for: method)
            classDecl += "\n"
        }

        classDecl += "}\n"

        return classDecl
    }

    private func computeFinalGenerics(for protocolInfo: ProtocolInfo) -> String? {
        if !protocolInfo.associatedTypes.isEmpty && protocolInfo.genericParameters == nil {
            let typeNames = protocolInfo.associatedTypes.map { $0.name }
            return "<\(typeNames.joined(separator: ", "))>"
        }
        return protocolInfo.genericParameters
    }

    private func computeFinalWhereClause(for protocolInfo: ProtocolInfo) -> String? {
        if !protocolInfo.associatedTypes.isEmpty && protocolInfo.genericParameters == nil {
            let constraints = protocolInfo.associatedTypes.compactMap { assocType -> String? in
                guard let constraint = assocType.constraints else { return nil }
                // Remove "where " prefix if present
                return constraint.hasPrefix("where ") ? String(constraint.dropFirst(6)) : constraint
            }
            if !constraints.isEmpty {
                return "where \(constraints.joined(separator: ", "))"
            }
        }
        return protocolInfo.whereClause
    }

    private func generateMockMethod(for method: MethodInfo) -> String {
        let funcName = method.name

        // Build argument array (skip variadic packs)
        let argElements = method.parameters.compactMap { param -> String? in
            if param.isVariadicPack { return nil }
            return param.internalName
        }
        let argsArrayLiteral = argElements.isEmpty ? "[]" : "[\(argElements.joined(separator: ", "))]"

        // Build method signature
        var signature = "    public func \(funcName)"

        if let genericParams = method.genericParameters {
            signature += genericParams
        }

        let paramStrings = method.parameters.map { param -> String in
            let namesPart: String
            if let external = param.externalName {
                if external == param.internalName {
                    namesPart = external
                } else {
                    namesPart = "\(external) \(param.internalName)"
                }
            } else {
                namesPart = "_ \(param.internalName)"
            }
            let defaultPart = param.defaultValue.map { " = \($0)" } ?? ""
            return "\(namesPart): \(param.type)\(defaultPart)"
        }

        signature += "(\(paramStrings.joined(separator: ", ")))"

        if method.isAsync {
            signature += " async"
        }
        if method.isThrowing {
            signature += " throws"
            if let clause = method.throwsClause, !clause.isEmpty {
                signature += clause
            }
        }
        if let returnType = method.returnType {
            signature += " -> \(returnType)"
        }
        if let whereClause = method.genericWhereClause {
            signature += " \(whereClause)"
        }

        // Build method body
        var body = " {\n"
        body += "        let matchers = MatcherRegistry.shared.extractMatchers()\n"
        body += "        let matchMode: MethodCall.MatchMode = matchers.isEmpty ? .exact : .matchers(matchers)\n"
        body += "        let call = MethodCall(mockId: _mockId, name: \"\(funcName)\", args: \(argsArrayLiteral), matchMode: matchMode)\n"
        body += "        _recorder.record(call)\n"

        // Add stub lookup
        let hasReturnValue = method.returnType != nil
        let hasTypedThrows = method.hasTypedThrows
        let errorTypeName = method.typedThrowsErrorType ?? ""

        if hasReturnValue {
            if method.isAsync && method.isThrowing {
                if hasTypedThrows {
                    body += "        return try await _mockGetTypedAsyncStub(\n"
                    body += "            for: call, mockMode: _mockMode, errorType: \(errorTypeName).self)\n"
                } else {
                    body += "        return try await _mockGetAsyncStub(for: call, mockMode: _mockMode)\n"
                }
            } else if method.isAsync {
                body += "        return try! await _mockGetAsyncStub(for: call, mockMode: _mockMode)\n"
            } else if method.isThrowing {
                if hasTypedThrows {
                    body += "        return try _mockGetTypedStub(\n"
                    body += "            for: call, mockMode: _mockMode, errorType: \(errorTypeName).self)\n"
                } else {
                    body += "        return try _mockGetStub(for: call, mockMode: _mockMode)\n"
                }
            } else {
                body += "        return try! _mockGetStub(for: call, mockMode: _mockMode)\n"
            }
        } else {
            // Void method
            if method.isThrowing {
                if hasTypedThrows {
                    body += "        try _mockExecuteTypedThrowingStub(for: call, errorType: \(errorTypeName).self)\n"
                } else {
                    body += "        try _mockExecuteThrowingStub(for: call)\n"
                }
            }
        }

        body += "    }\n"

        return signature + body
    }

    private func generateMockProperty(for property: PropertyInfo) -> String {
        var output = ""

        // Generate backing storage
        output += "    private var _\(property.name): \(property.type)?\n"

        if property.isGetSet {
            // Get-set property
            output += """
                public var \(property.name): \(property.type) {
                    get {
                        let matchers = MatcherRegistry.shared.extractMatchers()
                        let matchMode: MethodCall.MatchMode = matchers.isEmpty ? .exact : .matchers(matchers)
                        let call = MethodCall(mockId: _mockId, name: "get_\(property.name)", args: [], matchMode: matchMode)
                        _recorder.record(call)
                        if let value = _\(property.name) {
                            return value
                        }
                        return try! _mockGetStub(for: call, mockMode: _mockMode)
                    }
                    set {
                        let matchers = MatcherRegistry.shared.extractMatchers()
                        let matchMode: MethodCall.MatchMode = matchers.isEmpty ? .exact : .matchers(matchers)
                        let call = MethodCall(mockId: _mockId, name: "set_\(property.name)", args: [newValue], matchMode: matchMode)
                        _recorder.record(call)
                        _\(property.name) = newValue
                    }
                }

            """
        } else {
            // Get-only property
            output += """
                public var \(property.name): \(property.type) {
                    get {
                        let matchers = MatcherRegistry.shared.extractMatchers()
                        let matchMode: MethodCall.MatchMode = matchers.isEmpty ? .exact : .matchers(matchers)
                        let call = MethodCall(mockId: _mockId, name: "get_\(property.name)", args: [], matchMode: matchMode)
                        _recorder.record(call)
                        if let value = _\(property.name) {
                            return value
                        }
                        return try! _mockGetStub(for: call, mockMode: _mockMode)
                    }
                }

            """
        }

        return output
    }
}
